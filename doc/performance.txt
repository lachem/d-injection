Dependency Injection Performance Note
=====================================

DI has been optimized both in terms of speed and memory consumption. However due to the necessity of using certain constructs to handle injections, there are rules that need to be followed to retain this efficiency.

Avoid postponed building
------------------------
Objects should be built immiedietely after they are instatiated. This is due to the fact that injectable class attributes are written into global containers after object instantiation. Those global containers (which are traversed during building) are optimized for a small number of simultanously awaiting injections (see DI_MAX_INJECTIONS_PER_TYPE). Thus deferring building may cause a decrease in efficiency. 

.Inefficient
---------------------------------------------------------------------
std::vector<TypeWithInjections> container;
...
for(int i=0; i<100000; i++) {
	container.push_back(TypeWithInjections());
}
...
for(int i=0; i<100000; i++) {
	builder.build(container[i]);
}
---------------------------------------------------------------------

.Efficient
---------------------------------------------------------------------
std::vector<TypeWithInjections> container;
...
for(int i=0; i<100000; i++) {
	container.push_back(TypeWithInjections());
	builder.build(container[i]);
}
---------------------------------------------------------------------

.Inefficient
---------------------------------------------------------------------
std::vector<TypeWithInjections> container(100000);
for(int i=0; i<100000; i++) {
	builder.build(container[i]);
}
---------------------------------------------------------------------

.Efficient
---------------------------------------------------------------------
TypeWithInjections prototype;
builder.build(prototype);
std::vector<TypeWithInjections> container(100000,prototype);
---------------------------------------------------------------------

Prefer build to build_part
--------------------------
