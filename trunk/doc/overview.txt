Dependency Injection Overview
=============================

Introduction
------------

This library is header only. To use it, it's enough to include di/di.hpp in your project.

NOTE: dependency injection will be referred throughout this documentation simply as DI.

Dependency injection is an implementation of http://en.wikipedia.org/wiki/Inversion_of_control[Inversion of Control (IoC)] known from java frameworks such as http://en.wikipedia.org/wiki/Spring_Framework[Spring] or http://www.qi4j.org/[Qi4j]. Still C\++ community lacks a dependency injection framework that would be portable and independent from libraries like Qt. This is an attempt to create a simple yet powerful DI library built on http://www.boost.org/[boost] (and in future in pure C++11).

Injection subject
-----------------
A class that requires some objects to be injected into it upon instantiation or delegation has to be declared an injection subject.This is achieved by subclassing +di::subject+ class (declared in di/subject.hpp) in the following manner:
     
---------------------------------------------------------------------
struct MyClass: public di::subject<T,U,V,...>{};
---------------------------------------------------------------------
Template parameters of the +di::subject+ name the types of each particular injection. For the sake of clarity, let us consider a simple example. Assuming that a Car class requires four wheels, one handbrake and two seats, its declaration would look like this:
     
---------------------------------------------------------------------
struct Car: public di::subject<Wheel,Wheel,Wheel,Wheel,HandBrake,Seat,Seat>{};
---------------------------------------------------------------------
However the order of those parameters is not important. At this point only the quantity of each type matters. Therefore declaration below is equivalent to the one above.
  
---------------------------------------------------------------------
struct Car: public di::subject<Seat,Wheel,Wheel,HandBrake,Wheel,Seat,Wheel>{};
---------------------------------------------------------------------
  
Declaring injections
--------------------
Having declared a class an injection subject it is possible to specify its injections. The types of injections have to match those defined in template parameters of +di::subject+, though as already mentioned there is no relation between their order. Continuing previous example, injection definitions might look like this:
     
---------------------------------------------------------------------
struct Car: public di::subject<Seat,Wheel,Wheel,HandBrake,Wheel,Seat,Seat,Wheel>
{
    di::required<Wheel> frontLeftWheel; 
    di::required<Wheel> frontRightWheel; 
    di::required<Wheel> rearLeftWheel; 
    di::required<Wheel> rearRightWheel; 
    di::required<Seat> leftSeat; 
    di::required<Seat> rightSeat; 
    di::optional<Seat> backSeat; 
    di::required<HandBrake> handBrake;
 
    Car() 
    {
        //injections are not yet available 
    }
};
---------------------------------------------------------------------
  
+di::required+ class is defined in di/required.hpp and +di::optional+ class is defined in di/optional.hpp header. Both +di::required+ and +di::optional+ have pointer semantics and are convertible to pointer or reference of their template arguments. The injection itself is performed right after leaving a constructor. Therefore using any of the required/optional objects inside constructor is equivalent to using an uninitialized pointer, in fact it is exactly the same.

Types of injections
-------------------

There are situtations when it is impossible to determine which part of a system is responsible for releasing some object. In such cases some kinds of smart pointers can be used. Also di provides means of handling pointers in different ways. There are four distinct types of injections. All of them have pointer semantics.

* di::ordinary
* di::shared
* di::unique
* di::service

di::ordinary
~~~~~~~~~~~~
Indicates that the injection is represented as a bare pointer and the user is responsible for deleting the object. 

NOTE: not providing injection type at all is equivalent to using di::ordinary.

---------------------------------------------------------------------
struct Car: public di::subject<Wheel> 
{ 
    di::required< di::ordinary<Wheel> > wheel; 
};
---------------------------------------------------------------------
is the same as
---------------------------------------------------------------------
struct Car: public di::subject<Wheel> 
{ 
    di::required<Wheel> wheel; 
};
---------------------------------------------------------------------

di::shared
~~~~~~~~~~
Indicates that the injection is represented as a shared_ptr. Therefore object will be released when there are no more associations to it. Due to its internal represantation +di::shared+ injections can be converted to +boost::shared_ptr+.

---------------------------------------------------------------------
struct Car: public di::subject<Wheel> 
{ 
    di::optional< di::shared<Wheel> > wheel; 
};
---------------------------------------------------------------------
 
di::unique
~~~~~~~~~~
Indicates that the injection will be represented as +auto_ptr+ (or +unique_ptr+ when C++11 will be used). Obviously, injection subject which requires an injection of type +di::unique+ will become noncopyable.

---------------------------------------------------------------------
// Car is noncopyable bacause wheel injection is of type di::unique 
struct Car: public di::subject<Wheel> 
{ 
    di::optional< di::unique<Wheel> > wheel; 
};
---------------------------------------------------------------------

di::service
~~~~~~~~~~~
Is a special kind of injection that is used in conjunction with di::module and di::application. It is represented by a +boost::shared_ptr+ and can be converted to it.

---------------------------------------------------------------------
struct Car: public di::subject<Wheel> 
{ 
    di::optional< di::service<Logger> > logger; 
};
---------------------------------------------------------------------
  
Builder
-------
The most basic form of building an injection subject is by utilizing +builder+ defined in di/builder.hpp.+di::builder+ is a class with two template paramters from which only one is obligatory. Having a car class that derives from +di::subject with+ injections specified +builder+ can be used to create +Car+ instance. First however what is necessary is to provide objects for injections by calling template method +use+ on builder object.

---------------------------------------------------------------------
di::builder<Car> builder;
  
Wheel w1,w2,w3,w4;
builder.use(w1).use(w2).use(w3).use(w4);
  
Seat s1,s2;
HandBrake hb;
builder.use(s1).use(s2).use(hb);
  
Car* car = builder.build();
  
assert(&w1 == car->frontLeftWheel);
assert(&w2 == car->frontRightWheel);
assert(&w3 == car->rearLeftWheel);
assert(&w4 == car->rearRightWheel);
assert(&s1 == car->leftSeat);
assert(&s1 == car->rightSeat);
assert( 0  == car->backSeat);
assert(&hb == car->handBrake);
---------------------------------------------------------------------
In contradiction to subject's template parameters, the order of use calls is strictly bound to the order in which 
requireds and optionals are declared. This relies to the order of requireds and optionals of same types e.g. in the above example changing the order of use calls, such that +builder.use(w4).use(w2).use(w3).use(w1);+ would result in +car\->frontLeftWheel == &w4+ and +car\->rearRightWheel == &w1+. For the same reason changing the order in which optionals and requireds are declared would result in and error (assert, exception etc. depending on user's choice), because the third second seat passed to builder would be injected into optional, thus leaving the last +required<Seat>+ unsatisfied.

---------------------------------------------------------------------
struct Car: public di::subject<Seat,Wheel,Wheel,HandBrake,Wheel,Seat,Wheel>
{ 
    di::required<Wheel> frontLeftWheel;  //<-- first use<Wheel>(...) call 
    di::required<Wheel> frontRightWheel; //<-- second use<Wheel>(...) call 
    di::required<Wheel> rearLeftWheel;   //<-- third use<Wheel>(...) call 
    di::required<Wheel> rearRightWheel;  //<-- fourth use<Wheel>(...) call 
    di::required<Seat> leftSeat;  //<-- first use<Seat>(...) call 
    di::required<Seat> rightSeat; //<-- second use<Seat>(...) call 
    di::optional<Seat> backSeat; //<-- third use<Seat>(...) call 
    di::required<HandBrake> handBrake; //<-- first use<HandBrake>(...) call 
}; 
---------------------------------------------------------------------
  
---------------------------------------------------------------------
struct Car: public di::subject<Seat,Wheel,Wheel,HandBrake,Wheel,Seat,Wheel>
{ 
    di::required<Wheel> frontLeftWheel;  //<-- first use<Wheel>(...) call 
    di::required<Wheel> frontRightWheel; //<-- second use<Wheel>(...) call 
    di::required<Wheel> rearLeftWheel;   //<-- third use<Wheel>(...) call 
    di::required<Wheel> rearRightWheel;  //<-- fourth use<Wheel>(...) call 
    di::required<Seat> leftSeat;  //<-- first use<Seat>(...) call 
    di::optional<Seat> backSeat; //<-- second use<Seat>(...) call 
    di::required<Seat> rightSeat; //<-- third use<Seat>(...) call
    //builder knows only about two seats, third seat will cause an error 
    di::required<HandBrake> handBrake; //<-- first use<HandBrake>(...) call 
};
---------------------------------------------------------------------

NOTE: All builders are injection type aware i.e. +builder.use(di::shared<Wheel>(w1));+ will be injected to +di::required< di::shared<Wheel> >+ and not to +di::required<Wheel>+.
  
Abstract builder
----------------
In many cases it may be impractical to use raw +builder<typename T> + due to coupling and testability issues. Prefferably one might want to be able to build an object of +class Car+ but pass an object of +class Vehicle+ (base of Car) to be able to change at any point of the develepment the Car object to some other type of Vehicle e.g. a bicycle. Furthermore it is reasonable to expect to have the possibility of mocking +builder::build()+ and +builder::build(T&)+ methods to build/inject mocks/stubs instead of real objects. To achieve all these benefits +di::abstract_builder+ is provided. +di::abstract_builder+ is the base class of +di::builder+, hence the name.

Considering:

---------------------------------------------------------------------
struct Vehicle : public di::subject<Seat,Wheel,Wheel,HandBrake,Wheel,Seat,Wheel> 
{ 
    virtual void move(...) = 0;
};
  
struct Car: public Vehicle
{ 
    di::required<Wheel> frontLeftWheel;  
    di::required<Wheel> frontRightWheel; 
    di::required<Wheel> rearLeftWheel;   
    di::required<Wheel> rearRightWheel;  
    di::required<Seat> leftSeat;  
    di::required<Seat> rightSeat; 
    di::required<HandBrake> handBrake; 
    virtual void move(...) {...};
}; 
---------------------------------------------------------------------

one might write:

---------------------------------------------------------------------
di:abstract_builder<Vehicle>* vehicle_builder = new di::builder<Car,Vehicle>(); 
Vehicle* porshe = vehicle_builder->build();
---------------------------------------------------------------------

or:

---------------------------------------------------------------------
di:abstract_builder<Vehicle>* vehicle_builder = new di::builder<Car,Vehicle>() 
... 
Car porshe(...); 
vehicle_builder->build(porshe); 
---------------------------------------------------------------------
  
NOTE: It is the class which is the template parameter of +di::abstract_builder+ that needs to derive (publicly) from di::subject. Unfortunately this a necessary limitation.
          
Building families of objects
----------------------------
Aforementioned +di::abstract_builder::build(T&)+ method allows for building families of objects. I the provided example all the classes which are subclasses of +Construct+ are considered to be of one family and can be build using the same builder. Additionaly this example has been enriched with a code showing a two phased building (trucks are built once for theirs Construct-subjects and once for theirs Vehicle-subjects).

---------------------------------------------------------------------
class Construct : public di::subject<Logger,Database,ConversionTools> {};
  
class ConstructImp : public Construct 
{ 
    di::required<Logger> log; 
    di::required<Database> db; 
    di::required<ConversionTools> conversion; 
}; 
  
class Truck : public Car, public ConstructImp {};
  
class Road : public ConstructImp {};
  
class Garage : public ConstructImp {}; 
  
  
Truck scania;
Truck mercedes;
Road highway;
Garage garage1,garage2;
  
... 
  
di:abstract_builder<Vehicle>* vehicle_builder = new di::builder<Car,Vehicle>() 
di:abstract_builder<Construct>* construct_builder = new di::builder<Construct,ConstructImp>() 
//setup both builders 
  
... 
  
vehicle_builder->build(scania); 
construct_builder->build(scania); 
  
vehicle_builder->build(mercedes); 
construct_builder->build(mercedes); 
  
construct_builder->build(highway);
construct_builder->build(garage1);
construct_builder->build(garage2);
---------------------------------------------------------------------
  
Generic builder
---------------
Generic builder is another kind of builder that has been designed to inject dependencies into any type of subjects. Extending previous example one may consider set of subject types which are interested in the same injections. It would be inconvienient to setup many abstract builder for separate types with the same injections. To illustrate the problem consider a logger instance which ought to be passed to each object in the system. 

---------------------------------------------------------------------
class Truck : public di::subject<Logger> 
{
    di::required<Logger> log; 
};
  
class Road : public di::subject<Logger,Database,ConversionTools> 
{ 
    di::required<Logger> log; 
    di::required<Database> db; 
    di::required<ConversionTools> conversion; 
}; 
  
class Garage : public di::subject<Logger,Database,ConversionTools> 
{ 
    di::required<Logger> log; 
    di::required<Database> db; 
    di::required<ConversionTools> conversion; 
}; 
  
  
Truck scania;
Truck mercedes;
Road highway;
Garage garage1,garage2;
  
... 
  
di::generic_builder< di::subject<Logger> > gbuilder; 
gbuilder.use(loggerInstance); 
...
gbuilder.build(scania); 
gbuilder.build(mercedes); 
gbuilder.build_part(highway); 
gbuilder.build_part(garage1); 
gbuilder.build_part(garage2); 
//inject rest of required dependencies to highway, garage1, garage2 using 
//abstract_builder or another generic_builder
---------------------------------------------------------------------

The difference between +di::generic_builder<...>::build_part+ and +di::generic_builder<...>::build+ is that +build_part+ does not check whether all requirements have been met. This way issuing +gbuilder.build(scania)+ is perfectly fine because +Logger+ is the only dependency required by +Truck+ whereas issuing +gbuilder.build(highway)+ would result in an error (assertion, exception or custom defined), while +di::generic_builder< di::subject<Logger> >+ does not provide +Database+ and +ConversionTools+ required by +Road+. Additionally in contradiction to +di::generic_builder<...>::build+ +di::generic_builder<...>::build_part+ does not invoke subject's +constructed+ method.

Modules
-------
Apart from class level dependencies DI introduces also a way to handle dependecies in a more coarse-grained level. This is achieved by logicaly dividing an application into modules. Each module defines a list of services it provides and a list of services it needs in following manner:

---------------------------------------------------------------------
struct Controller 
{ 
    di::service_list<ActionHandler> provided; 
    di::service_list<Logger,Database> needed; 
}; 
struct Infrastructure 
{ 
    di::service_list<Logger,Database> provided; 
    di::service_list<> needed; 
}; 
struct UI 
{ 
    di::service_list<> provided; 
    di::service_list<ActionHandler> needed; 
}; 
---------------------------------------------------------------------

The implementer of each module is responsible for providing pointers to those services. 

---------------------------------------------------------------------
// Controller module code 
di::module<Controller>& controllerModule; 
ActionHandler handler; 
controllerModule.use(di::service<ActionHandler>(handler)); 
... 
//Infrastructure module code 
di::module<Infrastructure>& infrastructureModule; 
Logger logger; 
Database db; 
infrastructureModule.use(di::service<Logger>(logger)).use(di::service<Database>(db)); 
---------------------------------------------------------------------

Modules are connected to each other. Therefore all of the Modules should firstly provide their services by calling the +di::module<Module>::use+ method before any of them could obtain any of the needed services.
      
Modules work in terms services. Only one instance per service type is supported. That is neither one module nor two different
modules can provide two services of the same type. Although if required user might use BOOST_STRONG_TYPEDEF to create multiple distinct types for the same service type to indicate which provider should be connected to which needer.
  
Application
-----------

Application is a construct that binds modules with each other. For example to bind previously defined Controller, Infrastructure and UI modules an application object should be created

---------------------------------------------------------------------
di::application<Controller,Infrastructure,UI> application;
---------------------------------------------------------------------

to obtain +di::module+ s from application instance

---------------------------------------------------------------------
di::module<Controller>& controllerModule = application; 
di::module<Infrastructure>& infrastructureModule = application; 
di::module<UI>& uiModule = application; 
---------------------------------------------------------------------

This way +controllerModule+, +infrastructureModule+ and +uiModule+ can be fed up seperately.


''''

Copyright (C) 2012 mailto:salvage@o2.pl[Adam Lach]

Distributed under the Boost Software License, Version 1.0. (See accompanying file http://www.boost.org/doc/libs/1_46_1/LICENSE_1_0.txt[LICENSE_1_0.txt] or copy at http://www.boost.org/LICENSE_1_0.txt).