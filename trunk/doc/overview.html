<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
  <meta http-equiv="Content-Language" content="en-us">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
  <link rel="stylesheet" type="text/css" href="style/boost.css">

  <title>Dependency Injection</title>
<link rel="icon" href="http://www.boost.org/favicon.ico" type="image/ico"><link rel="stylesheet" type="text/css" href="style/section-basic.css"></head>

<body link="#0000FF" vlink="#800080">  <div id="boost-common-heading-doc">

  <div id="boost-common-heading-doc-spacer"></div>

  
	<h1 align="center"><a href="index.html">Dependency Injection</a></h1>

	<h2 align="center">Overview</h2>
	<dl class="index">
	<dt><a href="#introduction">Introduction</a></dt>

	<dt><a href="#di_subject">Injection subject</a></dt>

	<dt><a href="#injections">Declaring injections</a></dt>

	<dt><a href="#injection_types">Types of injections</a></dt>
	
	<dt><a href="#builder">Builder</a></dt>

	<dt><a href="#abstract_builder">Abstract builder</a></dt>
	
	<dt><a href="#building_families">Building families of objects</a></dt>
	
	<dt><a href="#generic_builder">Generic builder</a></dt>
	
	<dt><a href="#modules">Modules</a></dt>

	<dt><a href="#application">Application</a></dt>
	
    <!--dt><a href="#footnotes">Footnotes</a></dt-->
  </dl>

  <h2><a name="introduction" id="introduction"></a>Introduction</h2>

  <p>Header only. Include di/di.hpp. Dependency injection will be referred throughout this documentation simply as DI. </p>
  <p>
	 Dependency injection is an implementation of Inversion of Control (IoC) known from java frameworks such as Spring or Qi4j. 
	 Still C++ community lacks a Dependency Injection framework that would be portable and independent from such libraries
	 like Qt. This is an attempt to create a simple yet powerful DI library build on boost (in future in pure C++11).
  </p>

  <h2><a name="di_subject" id="di_subject"></a>Injection subject</h2>

  <p>Given a class that requires some objects to be injectected into it upon instantion or delegation. That class has to be declared an injection subject.
     This is achieved by subclassing di::subject class (declared in di/subject.hpp) in the following manner:</p>
	 
  <code> 
  struct MyClass: public di::subject&lt;T,U,V,...&gt;{};
  </code>
  
  <p>Template paramaters of the subject class name the types of each particular injection. For the sake of clarity, let us consider some simple example. 
	 Assuming that a Car class requires four wheels, one handbrake and two seats, its declaration would look like this: </p>
	 
  <code> 
  struct Car: public di::subject&lt;Wheel,Wheel,Wheel,Wheel,HandBrake,Seat,Seat&gt;{};
  </code>
  
  <p> However the order of those types is not important. The only thing thing that matters is their
	  quantity. Therefore the below declaration is equivalent to the one above. </p>
  
  <code> 
  struct Car: public di::subject&lt;Seat,Wheel,Wheel,HandBrake,Wheel,Seat,Wheel&gt;{};
  </code>
  
  <h2><a name="injections" id="injections"></a>Declaring injections</h2>

  <p>Having declared a class an injection subject it is possible to specify its injections. The types of injections have to match those defined
	 in template parameters of di::subject, though as already mentioned there is no relation between their order. Continuing previous example
	 injection definitions might look like: </p>
	 
  <code> 
  struct Car: public di::subject&lt;Seat,Wheel,Wheel,HandBrake,Wheel,Seat,Wheel&gt; <br />
  { <br />
  &nbsp; di::requried&lt;Wheel&gt; frontLeftWheel; <br />
  &nbsp; di::requried&lt;Wheel&gt; frontRightWheel; <br />
  &nbsp; di::requried&lt;Wheel&gt; rearLeftWheel; <br />
  &nbsp; di::requried&lt;Wheel&gt; rearRightWheel; <br />
  &nbsp; di::requried&lt;Seat&gt; leftSeat; <br />
  &nbsp; di::requried&lt;Seat&gt; rightSeat; <br />
  &nbsp; di::optional&lt;Seat&gt; backSeat; <br />
  &nbsp; di::requried&lt;HandBreak&gt; handBreak; <br />
  &nbsp; Car() <br />
  &nbsp; {<br />
  &nbsp; &nbsp; //injections are not yet available <br />
  &nbsp; }<br />
  };
  </code>
  
  <p><code>di::requried</code> class is defined in di/requried.hpp and <p><code>di::optional</code> class is defined in di/optional.hpp header.
  Both <code>di::requried</code> and <code>di::optional</code> have pointer semantics and are convertible to pointer or reference of its template argument. 
  The injection itself is performed right after leaving the constructor. Therefore using any of the requried/optional objects inside
  constructor is equivalent to using an uninitialized pointer, in fact it is exacly the same.</p>

  <h2><a name="injection_types" id="injection_types"></a>Types of injections</h2>

  <p> There are four distinct types of injections. All of them have pointer semantics.
	<ul>
	<li>di::ordinary</li>
	<li>di::shared</li>
	<li>di::unique</li>
	<li>di::service</li>
	</ul> 
  </p>
  <h4> di::ordinary </h4>
  <p> Indicates that the injection is represented as a bare pointer and the user is responsible for deleting the object. Using di::ordinary
	  is equivalent to not providing injection type at all.
  </p>
  <code> 
  struct Car: public di::subject&lt;Wheel&gt; <br />
  { <br />
  &nbsp; di::requried&lt; di::ordinary&lt;Wheel&gt; &gt; wheel; <br />
  };
  </code>
  <p> is the same as </p>
  <code> 
  struct Car: public di::subject&lt;Wheel&gt; <br />
  { <br />
  &nbsp; di::requried&lt;Wheel&gt; wheel; <br />
  };
  </code>
  <h4> di::shared </h4>
  <p> Indicates that the injection is represented as a shared_ptr. Threfore object will be released when there are no more associations
	  to it. Can be converted to shared_ptr.
  </p>
  <code> 
  struct Car: public di::subject&lt;Wheel&gt; <br />
  { <br />
  &nbsp; di::optional&lt; di::shared&lt;Wheel&gt; &gt; wheel; <br />
  };
  </code>
  <h4> di::unique </h4>
  <p> Indicates that the injection is represented as auto_ptr (in future it will be unique_ptr). The injection subject which requires
	  an injection of type di::unique will become noncopyable.
  </p>
  <code> 
  struct Car: public di::subject&lt;Wheel&gt; // Car is noncopyable bacause wheel injection is of type di::unique <br />
  { <br />
  &nbsp; di::optional&lt; di::unique&lt;Wheel&gt; &gt; wheel; <br />
  };
  </code>
  <h4> di::service </h4>
  <p> Is a special kind of injection that is used in conjunction with di::module and di::application. It is represented by a shared_ptr
	  and can be converted to it.
  </p>
  <code> 
  struct Car: public di::subject&lt;Wheel&gt; <br />
  { <br />
  &nbsp; di::optional&lt; di::service&lt;Logger&gt; &gt; logger; <br />
  };
  </code>

  <h2><a name="builder" id="builder"></a>Builder</h2>
  <p> The most basic form of building an injection subject is by utilizing <code>builder</code> defined in di/builder.hpp. 
  <code>di::builder</code> is a class with two template paramters from which only one is obligatory. Having a car class that
  derives from <code>di::subject with</code> injections specified <code>builder</code> can be used to create <code>Car</code>
  instance. First however what is necessary is to provide objects for injections by calling template method <code>use</code> 
  on builder object.
  </p>
  
  <code> 
  di::builder&lt;Car&gt; builder;<br />
  <br />
  Wheel w1,w2,w3,w4;<br />
  builder.use(w1).use(w2).use(w3).use(w4);<br />
  <br />
  Seat s1,s2;<br />
  HandBrake hb;<br />
  builder.use(s1).use(s2).use(hb);<br />
  <br />
  Car* car = builder.build();<br />
  <br />
  assert(&w1 == car->frontLeftWheel);<br />
  assert(&w2 == car->frontRightWheel);<br />
  assert(&w3 == car->rearLeftWheel);<br />
  assert(&w4 == car->rearRightWheel);<br />
  assert(&s1 == car->leftSeat);<br />
  assert(&s1 == car->rightSeat);<br />
  assert( 0  == car->backSeat);<br />
  assert(&hb == car->handBreak);<br />
  </code>
  <p> In contradiction to <code>subject</code>'s template parameters, the order of use calls is strictly bound to the order in which 
	  <code>requried</code>'s and <code>optional</code>'s are declared. This relies to the order of <code>requried</code>s and 
	  <code>optional</code>s of same types e.g. in the above example changing the order of use calls, such that 
	  <code>builder.use(w4).use(w2).use(w3).use(w1);</code> would result in <code> car->frontLeftWheel == &w4 </code> and 
	  <code> car->rearRightWheel == &w1 </code>. For the same reason changing the order in which <code>optional</code>s 
	  and <code>required</code>s are declared would result in and error (assert, exception etc. depending on user's choice), because
	  the third second seat passed to builder would be injected into <code>optional</code>, thus leaving the last 
	  <code>required&lt;Seat&gt;</code> unsatisfied.
  </p>
  <code> 
  struct Car: public di::subject&lt;Seat,Wheel,Wheel,HandBrake,Wheel,Seat,Wheel&gt;<br />
  { <br />
  &nbsp; di::requried&lt;Wheel&gt; frontLeftWheel;  //<-- first use&lt;Wheel&gt;(...) call <br />
  &nbsp; di::requried&lt;Wheel&gt; frontRightWheel; //<-- second use&lt;Wheel&gt;(...) call <br />
  &nbsp; di::requried&lt;Wheel&gt; rearLeftWheel;   //<-- third use&lt;Wheel&gt;(...) call <br />
  &nbsp; di::requried&lt;Wheel&gt; rearRightWheel;  //<-- fourth use&lt;Wheel&gt;(...) call <br />
  &nbsp; di::requried&lt;Seat&gt; leftSeat;  //<-- first use&lt;Seat&gt;(...) call <br />
  &nbsp; di::requried&lt;Seat&gt; rightSeat; //<-- second use&lt;Seat&gt;(...) call <br />
  &nbsp; di::optional&lt;Seat&gt; backSeat; //<-- third use&lt;Seat&gt;(...) call <br />
  &nbsp; di::requried&lt;HandBreak&gt; handBreak; //<-- first use&lt;HandBreak>(...) call <br />
  }; <br />
  </code>
  
  <code> 
  struct Car: public di::subject&lt;Seat,Wheel,Wheel,HandBrake,Wheel,Seat,Wheel&gt;<br />
  { <br />
  &nbsp; di::requried&lt;Wheel&gt; frontLeftWheel;  //<-- first use&lt;Wheel&gt;(...) call <br />
  &nbsp; di::requried&lt;Wheel&gt; frontRightWheel; //<-- second use&lt;Wheel&gt;(...) call <br />
  &nbsp; di::requried&lt;Wheel&gt; rearLeftWheel;   //<-- third use&lt;Wheel&gt;(...) call <br />
  &nbsp; di::requried&lt;Wheel&gt; rearRightWheel;  //<-- fourth use&lt;Wheel&gt;(...) call <br />
  &nbsp; di::requried&lt;Seat&gt; leftSeat;  //<-- first use&lt;Seat&gt;(...) call <br />
  &nbsp; di::<u>optional</u>&lt;Seat&gt; backSeat; //<-- second use&lt;Seat&gt;(...) call <br />
  &nbsp; di::<u>requried</u>&lt;Seat&gt; rightSeat; //<-- third use&lt;Seat&gt;(...) call, but builder knows only about two seats -> error <br />
  &nbsp; di::requried&lt;HandBreak&gt; handBreak; //<-- first use&lt;HandBreak&gt;(...) call <br />
  };
  </code>
  
  <h2><a name="abstract_builder" id="abstract_builder"></a>Abstract builder</h2>
  <p> In many cases it may be impractical to use raw <code> builder&lt;typename T&gt; </code> due to coupling and testability issues. Prefferably one might
	  want to be able to build an object of <code>class Car</code> but pass an object of <code>class Vehicle</code> (base of Car) to be able to change at
	  any point of the develepment the Car object to some other type of Vehicle e.g. a bicycle. Furthermore it is reasonable to expect to have the possibility of 
	  mocking <code>builder::build()</code> and <code>builder::build(T&)</code> methods to build/inject mocks/stubs instead of real objects. 
	  To achieve all these benefits <code>di::abstract_builder</code> is provided. <code>di::abstract_builder</code> is the base class of <code>di::builder</code>, hence the name.
  </p>
  <p> Considering: </p>
  <code>
  struct Vehicle : public di::subject&lt;Seat,Wheel,Wheel,HandBrake,Wheel,Seat,Wheel&gt; <br />
  { <br />
  &nbsp; virtual void move(...) = 0;<br />
  };<br />
  <br />
  struct Car: public Vehicle<br />
  { <br />
  &nbsp; di::requried&lt;Wheel&gt; frontLeftWheel;  <br />
  &nbsp; di::requried&lt;Wheel&gt; frontRightWheel; <br />
  &nbsp; di::requried&lt;Wheel&gt; rearLeftWheel;   <br />
  &nbsp; di::requried&lt;Wheel&gt; rearRightWheel;  <br />
  &nbsp; di::requried&lt;Seat&gt; leftSeat;  <br />
  &nbsp; di::requried&lt;Seat&gt; rightSeat; <br />
  &nbsp; di::requried&lt;HandBreak&gt; handBreak; <br />
  &nbsp; virtual void move(...) {...};<br />
  }; <br />
  </code>
  <p> one might write: </p>
  <code>
  di:abstract_builder&lt;Vehicle&gt;* vehicle_builder = new di::builder&lt;Car,Vehicle&gt(); <br />
  Vehicle* porshe = vehicle_builder->build();
  </code>
  <p> or: </p>
  <code>
  di:abstract_builder&lt;Vehicle&gt;* vehicle_builder = new di::builder&lt;Car,Vehicle&gt;() <br />
  ... <br />
  Car porshe(...); <br />
  vehicle_builder->build(porshe); <br />
  </code>
  
  <p> <b> Note!</b> It is the class which is the template parameter of <code> di::abstract_builder </code> that needs to derive (publicly) from di::subject. 
		  Unfortunately this a necessary limitation. </p>
		  
  <h2><a name="building_families" id="building_families"></a>Building families of objects</h2>
  <p> Aforementioned <code>di::abstract_builder::build(T&)</code> method allows for building families of objects. I the provided example all the classes
	  which are subclasses of <code>Construct</code> are considered to be of one family and can be build using the same builder. Additionaly this
	  example has been enriched with a code showing a two phased building (trucks are built once for theirs Construct-subjects and once for theirs
	  Vehicle-subjects).
  </p>
  <code>
  class Construct : public di::subject&lt;Logger,Database,ConversionTools&gt; {};<br />
  <br />
  class ConstructImp : public Construct <br />
  { <br />
	&nbsp; di::requried&lt;Logger&gt; log; <br />
	&nbsp; di::requried&lt;Database&gt; db; <br />
	&nbsp; di::requried&lt;ConversionTools&gt; conversion; <br />
  }; <br />
  <br />
  class Truck : public Car, public ConstructImp {};<br />
  <br />
  class Road : public ConstructImp {};<br />
  <br />
  class Garage : public ConstructImp {}; <br />
  <br />
  <br />
  Truck scania;<br />
  Truck mercedes;<br />
  Road highway;<br />
  Garage garage1,garage2;<br />
  <br />
  ... <br />
  <br />
  di:abstract_builder&lt;Vehicle&gt;* vehicle_builder = new di::builder&lt;Car,Vehicle&gt;() <br />
  di:abstract_builder&lt;Construct&gt;* construct_builder = new di::builder&lt;Construct,ConstructImp&gt;() <br />
  //setup both builders <br />
  <br />
  ... <br />
  <br />
  vehicle_builder->build(scania); <br />
  construct_builder->build(scania); <br />
  <br />
  vehicle_builder->build(mercedes); <br />
  construct_builder->build(mercedes); <br />
  <br />
  construct_builder->build(highway);<br />
  construct_builder->build(garage1);<br />
  construct_builder->build(garage2);<br />
  
  </code>
  
  <h2><a name="generic_builder" id="generic_builder"></a>Generic builder</h2>
  <p> Generic builder is another kind of builder that has been designed to inject dependencies into any type of subjects. Extending previous
	  example one may consider set of subject types which are interested in the same injections. It would be inconvienient to setup many
	  abstract builder for separate types with the same injections. To illustrate the problem consider a logger instance which ought to be 
	  passed to each object in the system. 
  </p>
  <code>
  class Truck : public di::subject&lt;Logger&gt; <br />
  {
	&nbsp; di::requried&lt;Logger&gt; log; <br />
  };<br />
  <br />
  class Road : public di::subject&lt;Logger,Database,ConversionTools&gt <br />
  { <br />
	&nbsp; di::requried&lt;Logger&gt; log; <br />
	&nbsp; di::requried&lt;Database&gt; db; <br />
	&nbsp; di::requried&lt;ConversionTools&gt; conversion; <br />
  }; <br />
  <br />
  class Garage : public di::subject&lt;Logger,Database,ConversionTools&gt; <br />
  { <br />
	&nbsp; di::requried&lt;Logger&gt; log; <br />
	&nbsp; di::requried&lt;Database&gt; db; <br />
	&nbsp; di::requried&lt;ConversionTools&gt; conversion; <br />
  }; <br />
  <br />
  
  Truck scania;<br />
  Truck mercedes;<br />
  Road highway;<br />
  Garage garage1,garage2;<br />
  <br />
  ... <br />
  <br />
  di::generic_builder&lt; di::subject&lt;Logger&gt; &gt; gbuilder; <br />
  gbuilder.use(loggerInstance); <br />
  ...<br />
  gbuilder.build(scania); <br />
  gbuilder.build(mercedes); <br />
  gbuilder.build_part(highway); <br />
  gbuilder.build_part(garage1); <br />
  gbuilder.build_part(garage2); <br />
  //inject rest of required dependencies to highway, garage1, garage2 using abstract_builder or another generic_builder
  </code>
  <p> The difference between <code>di::generic_builder&lt;...&gt;::build_part</code> and <code>di::generic_builder&lt;...&gt;::build</code> is that 
	  <code>build_part</code> does not check whether all requirements have been met. This way issuing <code>gbuilder.build(scania)</code> 
	  is perfectly fine because <code>Logger</code> is the only dependency required by <code>Truck</code> whereas issuing 
	  <code>gbuilder.build(highway)</code> would result in an error (assertion, exception or custom defined), while 
	  <code>di::generic_builder&lt; di::subject&lt;Logger&gt; &gt;</code> does not provide <code>Database</code> and 
	  <code>ConversionTools</code> required by <code>Road</code>. Additionally in contradiction to <code>di::generic_builder&lt;...&gt;::build</code> 
	  <code>di::generic_builder&lt;...&gt;::build_part</code> does not invoke subject's <code>constructed</code> method.
  </p>
  
  <h2><a name="modules" id="modules"></a>Modules</h2>

  <p> Apart from class level dependencies DI introduces also a way to handle dependecies in a more coarse-grained level. This is achieved by 
	  logicaly dividing an application into modules. Each module defines a list of services it provides and a list of services it needs in
	  following manner:
  </p>
  <code>
  struct Controller <br />
  { <br />
	&nbsp; di::service_list&lt;ActionHandler&gt; provided; <br />
	&nbsp; di::service_list&lt;Logger,Database&gt; needed; <br />
  }; <br />
  struct Infrastructure <br />
  { <br />
	&nbsp; di::service_list&lt;Logger,Database&gt; provided; <br />
	&nbsp; di::service_list&lt;&gt; needed; <br />
  }; <br />
  struct UI <br />
  { <br />
	&nbsp; di::service_list&lt;&gt; provided; <br />
	&nbsp; di::service_list&lt;ActionHandler&gt; needed; <br />
  }; <br />
  </code>
  <p> The implementer of each module is responsible for providing pointers to those services. <br />
  </p>
  <code>
  // Controller module code <br />
  di::module&lt;Controller&gt;& controllerModule; <br />
  ActionHandler handler; <br />
  controllerModule.use(di::service&lt;ActionHandler&gt;(handler)); <br />
  ... <br />
  //Infrastructure module code <br />
  di::module&lt;Infrastructure&gt;& infrastructureModule; <br />
  Logger logger; <br />
  Database db; <br />
  infrastructureModule.use(di::service&lt;Logger&gt;(logger)).use(di::service&lt;Database&gt;(db)); <br />
  </code>
  <p> Modules are connected to each other. Therefore all of the Modules should firstly provide their services by calling the 
	  <code>di::module&lt;Module&gt;::use</code> method before any of them could obtain any of the needed services.
  </p>
  <p> Modules work in terms services. Only one instance per service type is supported. That is neither one module nor two different
	  modules can provide two services of the same type. Although if required user might use BOOST_STRONG_TYPEDEF to create multiple 
	  distinct types for the same service type to indicate which provider should be connected to which needer.
  </p>
  
  <h2><a name="application" id="application"></a>Application</h2>

  <p> Application is a construct that binds modules with each other. For example to bind previously defined Controller, Infrastructure and UI 
	modules an application object should be created
  </p>
  <code>
  di::application<Controller,Infrastructure,UI> application;
  </code>
  <p> to obtain <code>di::module</code>s from application instance
  </p>
  <code>
  di::module<Controller>& controllerModule = application;
  di::module<Infrastructure>& infrastructureModule = application;
  di::module<UI>& uiModule = application;
  </code>
  <p> This way controllerModule, infrastructureModule and uiModule can be fed up seperately.
  </p>
  <!--h2><a name="footnotes" id="footnotes"></a>Footnotes</h2>

  <dl>
    <dt><a name="footnote1" class="footnote" id="footnote1">(1)</a>
    {{text}}</dt>

    <dt><a name="footnote2" class="footnote" id="footnote2">(2)</a>
    {{text}}</dt>
  </dl>
  <hr-->

  <p><a href="http://validator.w3.org/check?uri=referer"><img src="style/valid-html401.png" alt="Valid HTML 4.01 Transitional" border="0" height="31" width="88"></a></p>

  <p>Revised 
  <!--webbot bot="Timestamp" s-type="EDITED" s-format="%d %B, %Y" startspan -->
  6 October, 2012<!--webbot bot="Timestamp" endspan i-checksum="38514" --></p>

  <p><i>Copyright &#169; 2012 <a href="salvage@o2.pl">Adam Lach</a></i></p>

  <p><i>Distributed under the Boost Software License, Version 1.0. (See
  accompanying file <a href="http://www.boost.org/doc/libs/1_46_1/LICENSE_1_0.txt">LICENSE_1_0.txt</a> or
  copy at <a href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>)</i></p>


</body></html>
